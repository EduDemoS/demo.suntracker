/*                                                                                                           *
 *  Thank you for building EduDemoS!                                                                         *
 *                                                                                                           *
 *  This file is part of the EduDemoS Project and is licensed under the Creative Commons Attribution         *
 *  NonCommercial ShareAlike 4.0 International license (CC BY-NC-SA 4.0). For full license details, see the  *
 *  license.txt file or visit https://creativecommons.org/licenses/by-nc-sa/4.0/                             *     
 *                                                                                                           *
 *  EduDemoS is co-funded by the European Union. You can find more information at edudemos.eu                *                                                         
 *                                                                                                           *
 *  +-----------------------------------------------------------------------------------------------------+  *
 *                                                                                                           *
 *  The algorithm is based on the Arduino Solar Tracker guide:                                               *
 *  https://projecthub.arduino.cc/Aboubakr_Elhammoumi/arduino-solar-tracker-77347b                           */


// Include Libraries:
/* To setup the project:
    1. Create a copy of configuration.default.cpp
    2. Name the copy "configuration.cpp"
    3. Adjust the settings in configuration.cpp according to your needs 
       (look for @todo-comments) */
#include "configuration.cpp"
#include <Arduino.h>
#include <Servo.h>
#include <AccelStepper.h>
#include <LiquidCrystal_I2C.h>
#include <ESP8266WiFi.h>
#include <Wire.h>
#include <EEPROM.h>

#include <MqttClient.h>
#include <WiFiSecureClientProvider.h>

using namespace HolisticSolutions;
using namespace HolisticSolutions::WiFi;
using namespace HolisticSolutions::Mqtt;

#define DEMONSTRATOR_TYPE_NAME  "SUNFLOWER"
#define MQTT_DEVICE_NAME        DEMONSTRATOR_TYPE_NAME MQTT_TEAM_ID

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////                                   Objects and Variables                                    /////////

// Define Structure containing Stepper Motor data and create an instance of it:
struct StepperData
{
  int8_t        side = 0;                   // Which side of the Endstop the Stepper is.
  const int16_t stepsPerRotation = 10240;   // Number of Stepper steps in one flower rotation.
  const int16_t stepsPerDegree   = 28;      // Number of Stepper steps in one degree of flower rotation.
  int8_t        inverted         = -1;      // If the Stepper should be inverted.
  bool          zeroPressed      = false;   // If the Endstop Sensor is currently pressed.
};
StepperData stepperData;
AccelStepper stepper(AccelStepper::FULL4WIRE, PIN_STEPPER_0, PIN_STEPPER_2, PIN_STEPPER_1, PIN_STEPPER_3);

// Define Structure containing Sensor data:
struct SensorData
{
  bool    tooDark       = false;  // If it's currently too dark.
  int8_t  servoVelocity = 0;      // Actual current Servo speed
  int16_t diffElevation = 0;      // Difference between upper and lower LDR values
  int16_t diffAzimuth   = 0;      // Difference between left and right LDR values
  float   solarVoltage  = 0;      // Voltage generated by the Solar Panel
  uint8_t  PCFReadings[4];        // Raw LDR values received from the PCF Module
};
SensorData sensorData;

// Names for better readability:
#define STEPPER_SIDE_LEFT       1
#define STEPPER_SIDE_RIGHT     -1
#define STEPPER_DIRECTION_CW    1
#define STEPPER_DIRECTION_CCW  -1
#define STEPPER_SPEED           700
#define STEPPER_ACCEL           1000

// Define second LED Pin:
#ifndef LED_BUILTIN_AUX
#define LED_BUILTIN_AUX 16
#endif

// Create Servo Motor Object:
#define SERVO_PWM_90DEG ((SERVO_PWM_180DEG + SERVO_PWM_0DEG) / 2)
Servo servo;
int16_t servoAngle = SERVO_PWM_90DEG;

// Create LCD Display Object:
LiquidCrystal_I2C lcd(LCD_ADDR, 16, 2);
static SimpleSoftTimer i2c_scan_timeout(200);
static SimpleSoftTimer last_sensor_update_timeout(SENS_UPDATE_PERIOD);
static SimpleSoftTimer lcd_update_timeout(LCD_UPDATE_PERIOD);


// Create WiFi and MQTT Objects:
#if ENABLE_WIFI
static WiFiSecureClientProvider  upstream;
static MqttClient                mqtt(upstream);

static SimpleSoftTimer          _heartbeat_timeout(1000);
static SimpleSoftTimer          _mqtt_update(MQTT_UPDATE_PERIOD);
static bool                     _toggle = false;
static bool                     _mirror = false;

static int wifiStatus = WL_IDLE_STATUS;
static bool cancelWiFi = false;
static bool cancelMQTT = false;
#endif

// Signature for checking if saved data is valid:
#define EEPROM_SIZE           2
#define EEPROM_ADDR_SIGNATURE 0
#define EEPROM_ADDR_SIDE      1
#define EEPROM_SIGNATURE_BYTE 0x53  // 'S' in hexadecimal


/////////                                    Objects and Variables                                   /////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////                                    Function Prototypes                                     /////////

#if ENABLE_WIFI
// WiFi and MQTT Functions:
static void TaskCommunication(void);
static void TaskHeartbeat(void);

static bool connectToWiFi();
static bool connectToMQTT();

static MQTT_MESSAGE_HANDLER_DECLARE(OnMirrorReceived);

static void LogMessage(const char *topic, const void *data, size_t len);
static void SendJsonDoc(const char *topic, const JsonDocument &doc, bool retain = false);

template <typename T>
void SendDatapoint(const char *topic, const T& value, bool retain = false, const char *key = "value") {
  JsonDocument data;
  data[key] = value;
  SendJsonDoc(topic, data, retain);
}
#endif

// Functions using the I2C Bus (PCF8591 Module and LCD Display):
int  readPCFChannel(int channelID);
void receiveEvent(int eventCount);
bool scanForDevice(byte address);
inline void checkI2CDevices();
void printToLCD(const char* line1, const char* line2);
void printDataToLCD(int8_t verticalDirection, int8_t horizontalDirection, bool tooDark, float solarVoltage);

// Functions relating to the Stepper and Servo Motors:
void stepperFindZero();
void stepperBacktrack();
void IRAM_ATTR stepperZeroISR();

// Functions relating to saving/reading from flash storage:
bool checkStorageSignature();
bool writeStorageSignature();
bool readStepperSide();
bool writeStepperSide();

// Functions for main functionality:
void determineMovement(SensorData* data);
void moveMotors(SensorData* data);

// Other functions:
template<typename T> T signThresholded(T x);
template<typename T> T sign(T x);
#if ENABLE_STARTUP_CHECKS
bool runDiagnostics(bool checkLCD, bool checkPCF, bool checkWiFi, bool checkMQTT, bool checkServo);
#endif

void LogTiming(String msg);

/////////                                    Function Prototypes                                     /////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////                                           SETUP                                            /////////
void setup()
{
  // Double the CPU Frequency:
  os_update_cpu_frequency(160);

  // Start communication via USB (Serial):
  Serial.begin(SERIAL_BAUD_RATE);
  while(!Serial) delay(1);

  // Setup LCD Display:
  lcd.begin();

  // Setup I2C communication (LCD and PCF):
  Wire.onReceive(receiveEvent);

  // Print Welcome Message to Serial:
  Serial.println();
  Serial.println("Starting Sun-Tracker...");

  // Print Welcome Message to LCD:
  printToLCD("   Starting     ", 
             "  Sun-Tracker   ");
  delay(3000);

  // Setup Pins:
  pinMode(PIN_STEPPER_0,    OUTPUT);
  pinMode(PIN_STEPPER_1,    OUTPUT);
  pinMode(PIN_STEPPER_2,    OUTPUT);
  pinMode(PIN_STEPPER_3,    OUTPUT);
  pinMode(PIN_SOLAR_ADC,    INPUT);
  pinMode(PIN_ENDSTOP,      INPUT_PULLUP);
  pinMode(LED_BUILTIN_AUX,  OUTPUT);
  digitalWrite(LED_BUILTIN_AUX, HIGH);
  attachInterrupt(PIN_ENDSTOP, stepperZeroISR, FALLING);

#if ENABLE_WIFI
  // Connect to WiFi and MQTT:
  Serial.print("Resetting WiFi...");
  upstream.reset();
  Serial.println("done");
  
  Serial.print("Resetting MQTT client...");
  mqtt.reset();
  Serial.println("done");

  connectToWiFi();
  connectToMQTT();

  mqtt.subscribe("ctrl/mirror", MQTT_MESSAGE_HANDLER_NAME(OnMirrorReceived), 0);

  cancelWiFi = false;
  cancelMQTT = false;
#else
  Serial.println("IoT uplink disabled");
#endif

  // Setup Servo Motor:
  servo.attach(PIN_SERVO_PWM);
  servo.writeMicroseconds(servoAngle);
  
  // Read last known 'side' of Stepper Motor:
  if(!readStepperSide())
  {
    // If Side could neither be read nor written, there must be a storage issue.
    Serial.println("EEPROM Error: Could not read/write Stepper side.");
    
    // Assume that stepper is on the right:
    stepperData.side = STEPPER_SIDE_RIGHT;
  }

  // Setup Stepper Motor:
  stepper.setMaxSpeed(STEPPER_SPEED);
  stepper.setAcceleration(STEPPER_ACCEL);
  stepperFindZero();

  // Run Startup Checks:
  #if ENABLE_STARTUP_CHECKS
    Serial.println("Running Startup Checks...");
    bool result = runDiagnostics(true, true, false, false, true);
    Serial.println(result ? "All good." : "WARNING: Some checks failed!");
  #endif
  
  i2c_scan_timeout.restart();
  last_sensor_update_timeout.restart();
  lcd_update_timeout.restart();

#if ENABLE_WIFI
  _heartbeat_timeout.restart();
  _mqtt_update.restart();
#endif
}
/////////                                           SETUP                                            /////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////                                            LOOP                                            /////////
void loop()
{ 
  LogTiming("Loop Enter");
#if ENABLE_WIFI
  LogTiming("Comm");
  TaskCommunication();
  LogTiming("Heartbeat");
  TaskHeartbeat();

  if (!upstream.connected()
      || !mqtt.connected()) {
    if (lcd_update_timeout.isTimeout()) {
      lcd_update_timeout.restart();
      printToLCD((String("WiFi: ") + String(upstream.connected() ? "connected " : "connecting")).c_str(), 
                 (String("MQTT: ") + String(mqtt.connected() ? "connected " : "connecting")).c_str());
    }
    return;
  }
#endif

  LogTiming("Movements");
  moveMotors(&sensorData);

  // Regularly check for LCD and PCF:
  if (i2c_scan_timeout.isTimeout()) {
    checkI2CDevices();
    i2c_scan_timeout.restart();
  }

  moveMotors(&sensorData);

  // Regularly read new Sensor values and calculate necessary movement:
  if (last_sensor_update_timeout.isTimeout()) {
    determineMovement(&sensorData);
    last_sensor_update_timeout.restart();
  }

  // Move incrementally every loop (as fast as possible):
  moveMotors(&sensorData);

  // Regularly print to LCD Display:
  if (lcd_update_timeout.isTimeout()) {
    lcd_update_timeout.restart();
    printDataToLCD(signThresholded(sensorData.diffElevation), 
                   signThresholded(sensorData.diffAzimuth), 
                   sensorData.tooDark, sensorData.solarVoltage);
    
    #if ENABLE_SERIAL_DATA
      for(uint16_t i = 0; i < (sizeof(sensorData.PCFReadings) / sizeof(sensorData.PCFReadings[0])); i++)
      {
        Serial.print(sensorData.PCFReadings[i]);
        Serial.print(",");
      }
      Serial.print(sensorData.solarVoltage);
      Serial.println(",255");
    #endif
  }

  moveMotors(&sensorData);

#if ENABLE_WIFI
  // Regularly check wifi/mqtt connection and send data to MQTT Server:
  if (mqtt.connected() 
      && _mqtt_update.isTimeout()) {
      LogTiming("Upload live data start");

      // Normalize PCF Readings:
      JsonDocument ldr;

      ldr["ldr0"] = float(sensorData.PCFReadings[0]);
      ldr["ldr1"] = float(sensorData.PCFReadings[1]);
      ldr["ldr2"] = float(sensorData.PCFReadings[2]);
      ldr["ldr3"] = float(sensorData.PCFReadings[3]);

      LogTiming("Upload LDR data");
      SendJsonDoc("data/ldr", ldr);

      LogTiming("Upload solar voltage");
      SendDatapoint("data/solar", sensorData.solarVoltage);
      SendDatapoint("data/azimuth", stepper.currentPosition() / stepperData.stepsPerDegree);
      SendDatapoint("data/elevation", servo.read());

      _mqtt_update.restart();
      LogTiming("Upload live data done");
  }
#endif
  LogTiming("Loop Exit");
}
/////////                                            LOOP                                            /////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////                                         FUNCTIONS                                          /////////

// WiFi and MQTT Functions:
#if ENABLE_WIFI
static void TaskCommunication() {
  upstream.run();
  if (upstream.connected()) {
    mqtt.run();
  }
}

static void TaskHeartbeat() {
  if (_heartbeat_timeout.isTimeout()) {
    _heartbeat_timeout.restart();

    if (!mqtt.connected()) {
      Serial.println("...and my heart skips, skips a beat (no connection)");
      return;
    }

    JsonDocument heartbeat;
    heartbeat["state"] = _toggle ? "on" : "off";
    heartbeat["mirror"] = _mirror;
    SendJsonDoc("data/heartbeat", heartbeat);

    _toggle = !_toggle;
  }
}

// Connect to WiFi network.
static bool connectToWiFi()
{
  Serial.print("Connecting to WiFi network '");
  Serial.print(WIFI_SSID);
  Serial.print("' .");
  printToLCD(" Conn. Wifi...  ", WIFI_SSID);

  // Attempt WiFI connection:
  upstream.reset();
  upstream.connect(WIFI_SSID, WIFI_PASSWORD);

  return true;
}

// Establish connection with the MQTT Broker.
static bool connectToMQTT()
{
  // Return if wifi has been globally canceled:
  if(cancelWiFi || cancelMQTT) return false;

  Serial.print("Connecting to MQTT server  '" MQTT_SERVER "' .");
  printToLCD(" Conn. MQTT...  ", MQTT_SERVER);

  /* Only use this mode for experimental setups, 
    refrain from any productive use! */
  mqtt.InsecureAccept();

  if ((strlen(MQTT_WORKSHOP_ID) > 0) 
      && (strcmp(MQTT_WORKSHOP_ID, "undefined") != 0))
  {
    mqtt.TopicPrefixSet("EduDemoS/" MQTT_WORKSHOP_ID "/" MQTT_DEVICE_NAME);
  }
  else 
  {
    Serial.println("WARNING: Workshop ID not set");
    mqtt.TopicPrefixSet("EduDemoS/WSxxx/" MQTT_DEVICE_NAME);
  }

  mqtt.CredentialsSet(MQTT_USERNAME, MQTT_PASSWORD);
  mqtt.connect(MQTT_DEVICE_NAME, MQTT_SERVER, MQTT_PORT);

  return true;
}

static MQTT_MESSAGE_HANDLER_DECLARE(OnMirrorReceived) {
  const char *payload = (const char *)data;

  LogMessage(topic, data, len);

  _mirror = strncmp("on", payload, 2) == 0;
  mqtt.publish("data/mirror", _mirror ? "off" : "on");
}

static void LogMessage(const char *topic, const void *data, size_t len) {
  const char *message = (const char *)data;
  String text;
  
  text.concat(message, len);
  
  Serial.print("Topic: '" + String(topic) + "' Message: '" + text + "'");
}

static void SendJsonDoc(const char *topic, const JsonDocument &doc, bool retain) {
  String payload;
  serializeJson(doc, payload);
  mqtt.publish(topic, payload, retain);
}
#endif

// Functions using the I2C Bus (PCF8591 Module and LCD Display):

// Read the ADC value from a given channel on the PCF8591 module.
int  readPCFChannel(int channelID)
{
  Wire.beginTransmission(PCF8591_ADDR);
  Wire.write(0x40 | channelID);
  byte errorPCF = Wire.endTransmission();

  // Check for PCF errors:
  if(errorPCF)
  {
    // Evaluate Error code:
    Serial.print("I2C Error: ");
    Serial.print(errorPCF);
    Serial.print(" - ");
    switch(errorPCF)
    {
      case 1:  Serial.println("Data too long for buffer."); break;
      case 2:  Serial.println("NACK on address transmission (Device not found)"); break;
      case 3:  Serial.println("NACK on data transmission."); break;
      case 4:  Serial.println("Unknown I2C failure."); break;
      default: Serial.println("Unknown I2C failure."); break;
    }

    // Check for LCD Display:
    if(!scanForDevice(LCD_ADDR))
    {
      Serial.print("       --> LCD Display not detected! Check wiring. Check I2C address in datasheet (0x");
      Serial.print(LCD_ADDR, HEX);
      Serial.println("). If this happens sporadically, power off, wait 15s, power on.");
    }
    else
    {
      Serial.println("       --> LCD Display is connected.");
    }

    // Check for PCF Module:
    if(!scanForDevice(PCF8591_ADDR))
    {
      Serial.print("       --> PCF8591     not detected! Check wiring. Check I2C address in datasheet(0x");
      Serial.print(PCF8591_ADDR, HEX);
      Serial.println("). If this happens sporadically, power off, wait 15s, power on.");
    }
    else
    {
      Serial.println("       --> PCF8591     is connected.");
    }
    
    delay(100);
    return 0;
  }

  //Return voltage value:
  Wire.requestFrom(PCF8591_ADDR, 2);
  if(Wire.available() >= 2)
  {
    Wire.read();
    return Wire.read();
  }
  else
  {
    // PCF is not responding (despite no error before, this should not happen):
    Serial.println("I2C Error: PCF8591 is not responding with data!");
    delay(100);
  }
  return 0;
}

// Callback function for the I2C bus.
void receiveEvent(int eventCount)
{
  while(0 < Wire.available()) char c = Wire.read();
}

// Check if a device with the given address is on the I2C bus.
bool scanForDevice(byte address)
{
  Wire.beginTransmission(address);
  return (Wire.endTransmission() == 0); // Returns true if device is found.
}

// Check if LCD Display and PCF Module are properly connected. Run this function regularly.
inline void checkI2CDevices()
{
  // Check both devices:
  bool errorPCF = !scanForDevice(PCF8591_ADDR);
  bool errorLCD = !scanForDevice(LCD_ADDR);

  static bool ledStateAUX = false;

  // Blink LED in case of LCD/LED error:
#ifdef LED_BUILTIN_AUX
  if(errorPCF || errorLCD)
  {
    // Determine blink intervall:
    uint16_t blinkIntervall;
    if(errorLCD) blinkIntervall = 500;     // ... if only LCD is not found
    else         blinkIntervall = 1000;    // ... as soon as PCF is not found

    // Blink LED:
    static long lastBlinkupdate = 0;
    if((millis() - lastBlinkupdate) >= blinkIntervall)
    {
      digitalWrite(LED_BUILTIN_AUX, ledStateAUX ? LOW : HIGH);
      ledStateAUX = !ledStateAUX;
      lastBlinkupdate = millis();
    }
  }
  else
  {
    // If both modules are connected, turn off LED:
    digitalWrite(LED_BUILTIN_AUX, HIGH);
    ledStateAUX = false;
  }
  #endif

  // In case of only PCF error, print it to LCD:
    if(errorPCF && !errorLCD && !ledStateAUX)
    {
      printToLCD("   PCF Module   ",
                 "   NOT FOUND!   ");
    }
}

// Print both lines to the LCD Display. line1 and line2 must have 16 characters.
// Only actually updates the screen if the symbol has changed.
void printToLCD(const char* line1, const char* line2)
{
  // Remember last lines:
  static char lastLine1[17] = "                ";
  static char lastLine2[17] = "                ";

  for(uint8_t i = 0; i < 16; i++)
  {
    char c1 = (line1[i] == '\0') ? ' ' : line1[i];  // Replace null with space
    char c2 = (line2[i] == '\0') ? ' ' : line2[i];

    // Update character in the first line:
    if(c1 != lastLine1[i])
    {
      lcd.setCursor(i, 0);
      lcd.print(c1);
      lastLine1[i] = c1;
    }

    // Update character in the second line:
    if(c2 != lastLine2[i])
    {
      lcd.setCursor(i, 1);
      lcd.print(c2);
      lastLine2[i] = c2;
    }
  }
}

// Print an indicator of the current movement direction, the Motor angles and the current
// Solar Panel Voltage to the LCD Display.
void printDataToLCD(int8_t verticalDirection, int8_t horizontalDirection, bool tooDark, float solarVoltage)
{
  char line1[3] = "  ";
  char line2[3] = "  ";

  // Invert values:
  verticalDirection   *= -1;
  horizontalDirection *= -1;

  if(tooDark)
  {
    strcpy(line1, "--");
    strcpy(line2, "--");
  }
  else
  {
    // Determine horizontal component:
    if(horizontalDirection > 0)
    { // Left
      line1[0] = '#';
      line2[0] = '#';
    }
    else if(horizontalDirection < 0)
    { // Right
      line1[1] = '#';
      line2[1] = '#';
    }

    // Determine vertical component:
    if(verticalDirection > 0)
    { // Up
      line1[0] = '#';
      line1[1] = '#';
    }
    else if(verticalDirection < 0)
    {
      line2[0] = '#';
      line2[1] = '#';
    }
  }

  // If brightest spot has been found:
  if(!tooDark && !verticalDirection && !horizontalDirection)
  {
    strcpy(line1, "##");
    strcpy(line2, "##");
  }

  // +----------------+
  // |## Volt SRV STP |
  // |## 2.1V 120  34 |
  // +----------------+

  // Calculate Stepper angle:
  int16_t stepperAngle = stepper.currentPosition() / stepperData.stepsPerDegree;

  // Generate LCD Content:
  char lcdLine1[17];
  char lcdLine2[17];
  snprintf(lcdLine1, sizeof(lcdLine1), "%s Volt SVO STP",  line1);
  snprintf(lcdLine2, sizeof(lcdLine2), "%s %.1fV %3d %3d", line2, solarVoltage, servo.read(), stepperAngle);

  printToLCD(lcdLine1, lcdLine2);
}

// Functions relating to the Stepper Motor:

// Find the physical zero-point (Endstop Sensor) of the Stepper Motor.
void stepperFindZero()
{
  int8_t rotationDirection = -stepperData.side;
  
  String line2;
  if     (rotationDirection == STEPPER_DIRECTION_CCW) line2 = "      -->       ";
  else if(rotationDirection == STEPPER_DIRECTION_CW)  line2 = "      <--       ";
  else
  {
    // Fallback to default value (right) if 'side' is not valid:
    stepperData.side = STEPPER_SIDE_RIGHT;
    rotationDirection = -stepperData.side;
    line2 = "      <--       ";
  }

  Serial.print("Finding zero-position...");
  printToLCD("  Zeroing...    ", line2.c_str());

  // Check if Endstop Sensor is already pressed:
  if(!digitalRead(PIN_ENDSTOP) || stepperData.zeroPressed)
  {
    stepper.setCurrentPosition(0);
    Serial.println();
    Serial.println("Stepper is already in zero-position.");
    stepperData.zeroPressed = false;
    return;
  }

  // Set Stepper Target position to +200:
  const uint8_t maxAngle = 200;
  stepper.setCurrentPosition(0);
  stepper.moveTo(rotationDirection * stepperData.stepsPerDegree * maxAngle);

  // Rotate until Enstop is pressed. Reverse after 200:
  while(!stepperData.zeroPressed)
  {
    // Turn Stepper as long as target has not been reached:
    if(!stepper.run())
    {
      // Set new target on the opposite side:
      rotationDirection *= -1;
      stepper.moveTo(rotationDirection * stepperData.stepsPerDegree * maxAngle);
      if     (rotationDirection == STEPPER_DIRECTION_CCW) line2 = "      -->       ";
      else if(rotationDirection == STEPPER_DIRECTION_CW)  line2 = "      <--       ";
      printToLCD("  Zeroing...    ", line2.c_str());
    }

    // Run background activity to prevent crash:
    yield();
  }

  // If zero has been found, save it to memory:
  stepper.setCurrentPosition(0);
  Serial.println("Found.");
  printToLCD("     Zero       ",
             "     Found.     ");
}

// If the Stepper has turned too far in one direction, reverse it and the servo to
// continue on the other side.
void stepperBacktrack()
{
  long position = stepper.currentPosition();

  Serial.print("Stepper has turned too far. Backtracking...");
  printToLCD("Backtracking... ",
             "                ");

  // Set new Stepper Target to 180deg on the opposite side:
  int16_t stepsToGo = stepperData.stepsPerRotation / 2;
  if(sign(position) > 0) stepper.moveTo(position - stepsToGo);
  else                   stepper.moveTo(position + stepsToGo);

  uint8_t stepsTaken = 0;
  while(stepper.run())
  {
    // Run background activity to prevent crash:
    stepsTaken++;
    if(stepsTaken > 20)
    {
      yield();
      stepsTaken = 0;
    }
    delayMicroseconds(100);
  }

  // Determine Servo Step Size:
  const uint8_t servoSteps = 32;
  int16_t servoAnglePerStep = 2 * abs(SERVO_PWM_90DEG - abs(servoAngle)) / servoSteps;
  if(servoAngle > SERVO_PWM_90DEG) servoAnglePerStep = - servoAnglePerStep;

  // Move Servo:
  if(servoAnglePerStep != 0)
  {
    for(uint8_t i = 0; i < servoSteps; i++)
    {
      servoAngle += servoAnglePerStep;
      servo.writeMicroseconds(servoAngle);
      delay(1);
    }
  }
  
  Serial.println("Done.");

  // Save new side:
  stepperData.side = sign(stepper.currentPosition());
  writeStepperSide();

  // Reset Endstop Flag. Sensor will no longer be used.
  stepperData.zeroPressed = false;
}

// This Interrupt Service Routine (ISR) gets called immediately if the Endstop Sensor
// gets triggered and sets a flag for further processing in other functions.
void IRAM_ATTR stepperZeroISR()
{
  // Debounce zero button:
  static volatile long lastPressTime = 0;
  if((millis() - lastPressTime) >= 200)
  {
    stepperData.zeroPressed = true;
    lastPressTime = millis();
  }
}

// Functions relating to saving/reading from flash storage:

// Reads the signature and current side from storage. If the signature is invalid,
// write it again and assume that the stepper is on the right.
bool readStepperSide()
{
  // Read Signature and Stepper Side from Storage (EEPROM):
  EEPROM.begin(EEPROM_SIZE);
  bool success = true;

  // Read Signature:
  uint8_t signature = EEPROM.read(EEPROM_ADDR_SIGNATURE);
  if(signature == EEPROM_SIGNATURE_BYTE)
  {
    // Signature is valid, read the saved 'side' value:
    // (Subtract '1' to comply with uint8_t to int8_t conversion)
    byte readByte = EEPROM.read(EEPROM_ADDR_SIDE);
    stepperData.side = readByte - 1;
    Serial.print("EEPROM signature matches. Stepper side: ");
    Serial.print((stepperData.side == STEPPER_SIDE_LEFT) ? "left. (" : "right.(");
    Serial.print(stepperData.side);
    Serial.println(")");
  }
  else
  {
    // Signature is invalid:
    Serial.print("EEPROM signature mismatch! Expected/Read: 0x");
    Serial.print(EEPROM_SIGNATURE_BYTE, HEX);
    Serial.print("/0x");
    Serial.println(signature, HEX);

    // Assume stepper is on the right:
    stepperData.side = STEPPER_SIDE_RIGHT;
    success = writeStepperSide();
  }

  EEPROM.end();
  return success;
}

// Writes the signature and the current side of the stepper to permanent storage.
bool writeStepperSide()
{
  // Write Signature and Stepper Side to Storage (EEPROM):
  // (EEPROM.write() saves as uint8_t, but 'side' is int8_t. Add '1' to comply)
  Serial.print("Writing Stepper Side to storage... ");
  EEPROM.begin(EEPROM_SIZE);
  EEPROM.write(EEPROM_ADDR_SIGNATURE, EEPROM_SIGNATURE_BYTE);
  byte saveByte = stepperData.side + 1;
  EEPROM.write(EEPROM_ADDR_SIDE, saveByte);
  bool success = EEPROM.commit();
  EEPROM.end();

  if(!success)
  {
    Serial.println();
    Serial.println("EEPROM Error: Could not commit.");
    return false;
  }
  Serial.println("Done.");
  return true;
}

// Functions for main functionality:

void determineMovement(SensorData* data)
{
  // Read LDR values from PCF:
  for(uint8_t i = 0; i < 4; i++)
  {
    data->PCFReadings[i] = readPCFChannel(i);
  }

  // Read built in ADC value and convert it to solar panel voltage:
  uint16_t solarReading = analogRead(PIN_SOLAR_ADC);
  data->solarVoltage = float((solarReading) * 3.3 / 1024.0) * float((RESISTOR_SOL1 + RESISTOR_SOL2) / RESISTOR_SOL1);

  // Initialize directional averages. Remember them to average them with previous value (static)
  static uint8_t avgTop   = 0;
  static uint8_t avgBot   = 0;
  static uint8_t avgLeft  = 0;
  static uint8_t avgRight = 0;
  static uint8_t avgSum   = 0;

  // Calculate average brightness for all four directions. Add to previous values and calculate average of those:
  avgTop   = (data->PCFReadings[0] + data->PCFReadings[1]) >> 1;
  avgBot   = (data->PCFReadings[2] + data->PCFReadings[3]) >> 1;
  avgLeft  = (data->PCFReadings[0] + data->PCFReadings[2]) >> 1;
  avgRight = (data->PCFReadings[1] + data->PCFReadings[3]) >> 1;
  avgSum   = (data->PCFReadings[0] + data->PCFReadings[1] + data->PCFReadings[2] + data->PCFReadings[3]) > 2;

  //avgTop   /= 2;
  //avgBot   /= 2;
  //avgLeft  /= 2;
  //avgRight /= 2;
  //avgSum   /= 2;

  // Calculate brightness difference in azimuth and elevation:
  data->diffElevation = avgBot   - avgTop;
  data->diffAzimuth   = avgRight - avgLeft;

  // Determine movement:
  if(avgSum >= MIN_BRIGHTNESS)
  {
    // If one side (left/right) is brighter than the other...
    if(abs(data->diffAzimuth) >= DIFF_BRIGHTNESS)
    {
      // Set new stepper target (invert if flowerhead is above 90deg):
      stepper.move(sign(data->diffAzimuth) * stepperData.inverted * 50);
    }

    // If one side (above/below) is brighter than the other...
    if(abs(data->diffElevation) >= DIFF_BRIGHTNESS)
    {
      // Calculate servo motor speed:
      data->servoVelocity = data->diffElevation;
    }
    else
    {
      data->servoVelocity = 0;
    }

    data->tooDark = false;
  }
  else
  {
    data->tooDark = true;
  }
}

void moveMotors(SensorData* data)
{
  // Move Servo:
  if(servoAngle >= SERVO_PWM_0DEG && servoAngle <= SERVO_PWM_180DEG && !data->tooDark)
  {
    // Update Angle:
    servoAngle += (data->servoVelocity > 0) ? 1 : -1;

    // Make sure it stays within bounds:
    if(servoAngle < SERVO_PWM_0DEG)   servoAngle = SERVO_PWM_0DEG;
    if(servoAngle > SERVO_PWM_180DEG) servoAngle = SERVO_PWM_180DEG;

    // Invert Stepper if flowerhead is above 90deg:
    if(servoAngle > SERVO_PWM_90DEG) stepperData.inverted = -1;
    else                             stepperData.inverted =  1;

    // Move Servo Motor:
    servo.writeMicroseconds(servoAngle);
  }

  // Save Position before stepping in this loop:
  long lastStepperPosition = stepper.currentPosition();

  // Move Stepper:
  for(int i = 0; i < 20; i++)
  {
    stepper.runSpeedToPosition();
    delayMicroseconds(800);
  }

  // Check if zero has been crossed by comparing the sign of the last with the current position:
  stepperData.side = sign(stepper.currentPosition());
  if(sign(lastStepperPosition) != stepperData.side)
  {
    writeStepperSide();
  }

  // Check if Stepper has rotated more than 100deg either way from zero:
  static int16_t stepperLimit = stepperData.stepsPerDegree * BACKTRACK_LIMIT;
  if(abs(stepper.currentPosition()) >= stepperLimit)
  {
    // Backtrack to prevent tangling wires:
    stepperBacktrack();
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////                                    OTHER HELPER FUNCTIONS                                  /////////

// Return the sign of a value. If the value is less than DIFF_BRIGHTNESS, return 0.
template<typename T> T signThresholded(T x)
{
  if(abs(x) < DIFF_BRIGHTNESS) return 0;
  return (x > 0) - (x < 0);
}

// Return the sign of a value. If the value is 0, return 0.
template<typename T> T sign(T x)
{
  if(!x) return 0;
  T temp = (x > 0) - (x < 0);
  return (temp != 0) ? temp : 1;
}

// Check all detectable functionality. Returns 'false' if at least one check fails.
#if ENABLE_STARTUP_CHECKS
bool runDiagnostics(bool checkLCD, bool checkPCF, bool checkWiFi, bool checkMQTT, bool checkServo)
{
  bool successLCD   = !checkLCD;
  bool successPCF   = !checkPCF;
  bool successWiFi  = !checkWiFi;
  bool successMQTT  = !checkMQTT;

  // Look for LCD Display:
  if(checkLCD)
  {
    Serial.print("Looking for LCD Display...   ");
    successLCD = scanForDevice(LCD_ADDR);
    Serial.println(successLCD ? "Found." : "ERROR: NOT FOUND.");
  }

  // Look for PCF8591 Module:
  if(checkPCF)
  {
    Serial.print("Looking for PCF8591 Module...");
    successPCF = scanForDevice(PCF8591_ADDR);
    Serial.println(successPCF ? "Found." : "ERROR: NOT FOUND.");

    if(successLCD)
    {
      if(successPCF)
      {
        printToLCD("   PCF Module   ",
                   "     found.     ");
        delay(1000);
      }
      else
      {
        printToLCD("   PCF Module   ",
                   "   NOT FOUND!   ");
        delay(3000);
      }
    }
  }

  // Check WiFi connection:
  #if ENABLE_WIFI
  if(checkWiFi)
  {
    Serial.print("Checking WiFi connection...  ");

    String msg;
    auto wifiStatus = upstream.connected();

    if (wifiStatus) {
      msg = "WiFi connected.";
    }
    else {
      msg = "WiFi disconnected";
    }

    Serial.println(msg);
    successWiFi = wifiStatus;
    if(successLCD)
    {
      if(successWiFi)
      {
        printToLCD("    WiFi is     ",
                   "   connected.   ");
        delay(1000);
      }
      else
      {
        printToLCD("   WiFi ERROR   ", msg.c_str());
        delay(3000);
      }
    }
  }
  #else
    successWiFi = true;
  #endif

  // Check MQTT:
#if ENABLE_WIFI
  if(checkMQTT)
  {
    Serial.print("Checking MQTT connection...  ");
    auto wifiStatus = upstream.connected();
    String msg;
    if(!wifiStatus) {
      msg = "ERROR: NO WIFI";
    }
    else
    {
      successMQTT = mqtt.connected();
      if (successMQTT) {
        msg = "SUCCESS: Connected.";
      }
      else {
        msg = "Not yet connected";
      }
    }
    Serial.println(msg);

    if(successLCD)
    {
      if(successMQTT)
      {
        printToLCD("    MQTT is     ",
                   "   connected.   ");
        delay(1000);
      }
      else
      {
        printToLCD("   MQTT ERROR   ", msg.c_str());
        delay(3000);
      }
    }
  }
#else
  successMQTT = true;
#endif

  if(checkServo)
  {
    // 1. Move to 90deg position
    // 2. Turn to 110deg
    // 3. Turn to  70deg
    // 4. Turn to  90deg

    // Step 1:
    servo.writeMicroseconds(SERVO_PWM_90DEG);
    const uint16_t servoSteps = (SERVO_PWM_180DEG - SERVO_PWM_0DEG) * 1.0/9.0; // ^= 40deg

    // Step 2:
    Serial.println("Checking Servo: Turning to 130°");
    printToLCD("Checking Servo..",
               "Turning to 130  ");
    for(uint16_t i = 0; i < servoSteps; i++)
    {
      servoAngle += 2;
      servo.writeMicroseconds(servoAngle);
      delayMicroseconds(500);
    }

    // Step 3:
    Serial.println("Checking Servo: Turning to  50°");
    printToLCD("Checking Servo..",
               "Turning to  50  ");
    for(uint16_t i = 0; i < 2 * servoSteps; i++)
    {
      servoAngle -= 2;
      servo.writeMicroseconds(servoAngle);
      delayMicroseconds(500);
    }

    // Step 4:
    Serial.println("Checking Servo: Turning to  90°");
    printToLCD("Checking Servo..",
               "Turning to  90  ");
    for(uint16_t i = 0; i < servoSteps; i++)
    {
      servoAngle += 2;
      servo.writeMicroseconds(servoAngle);
      delayMicroseconds(500);
    }
    Serial.println("Servo check done.");
  }
  
  return (successLCD && successPCF && successWiFi && successMQTT);
}
#endif

void LogTiming(String msg) {
#if ENABLE_TIMING_LOG
  Serial.println(String(millis()) + " - " + msg);
#endif
}
/////////                                         FUNCTIONS                                          /////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////